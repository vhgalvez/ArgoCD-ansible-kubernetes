---
# ðŸ” Generar y sellar el Secret de autenticaciÃ³n bÃ¡sica para el Dashboard de ArgoCD
- name: ðŸ” Generar y sellar el Secret de basic-auth para ArgoCD Dashboard
  hosts: localhost
  gather_facts: false
  become: false

  vars_files:
    - ../vars/main.yml

  vars:
    files_dir: "{{ playbook_dir }}/files"
    secret_template: "../templates/secrets/basic-auth-secret.yaml.j2"
    rendered_unsealed_secret_path: "{{ files_dir }}/argocd-dashboard-secret-unsealed.yaml"
    sealed_secret_path: "{{ files_dir }}/argocd-dashboard-sealed.yaml"
    argocd_secret_name: "argocd-dashboard-auth"  # ðŸ‘ˆ Puedes cambiarlo si lo deseas

  pre_tasks:
    - name: "ðŸ› ï¸ Asegurar que el namespace {{ argocd_namespace }} existe"
      kubernetes.core.k8s:
        api_version: v1
        kind: Namespace
        name: "{{ argocd_namespace }}"
        state: present
        kubeconfig: "{{ kubeconfig_path }}"

    - name: ðŸ” Codificar contraseÃ±a de admin en base64
      set_fact:
        argocd_admin_password_b64: "{{ argocd_admin_password | b64encode }}"
      when: argocd_admin_password is defined

  tasks:
    # Verificar que kubeseal estÃ© instalado
    - name: ðŸ“‹ Verificar que kubeseal estÃ© instalado
      stat:
        path: "{{ kubeseal_path }}"
      register: kubeseal_check

    - name: âŒ Abortamos si kubeseal no estÃ¡ instalado
      fail:
        msg: "âŒ kubeseal no estÃ¡ instalado en {{ kubeseal_path }}"
      when: not kubeseal_check.stat.exists

    # Verificar que las variables estÃ©n definidas
    - name: âš™ï¸ Verificar que las variables estÃ©n definidas
      fail:
        msg: "âŒ Las variables ARGOCD_AUTH_USER y ARGOCD_AUTH_PASS no estÃ¡n definidas o vacÃ­as."
      when: argocd_auth_user | length == 0 or argocd_auth_pass | length == 0

    # Instalar htpasswd si no estÃ¡ instalado
    - name: ðŸ“¦ Instalar htpasswd (httpd-tools/apache2-utils)
      ansible.builtin.package:
        name: "{{ item }}"
        state: present
      become: true
      with_items:
        - httpd-tools   # Para CentOS/RHEL/Fedora
        - apache2-utils # Para Debian/Ubuntu

    # Generar la cadena bÃ¡sica con htpasswd (bcrypt)
    - name: ðŸ”‘ Generar cadena bÃ¡sica con htpasswd (bcrypt)
      shell: echo "{{ argocd_auth_pass }}" | htpasswd -i -B -n "{{ argocd_auth_user }}"
      register: basic_auth_string
      no_log: true

    # Debug: Verificar salida de htpasswd
    - name: ðŸ” Depurar salida de htpasswd (stdout y stderr)
      debug:
        msg:
          - "htpasswd stdout: {{ basic_auth_string.stdout }}"
          - "htpasswd stderr: {{ basic_auth_string.stderr }}"
          - "htpasswd rc: {{ basic_auth_string.rc }}"
      verbosity: 2

    # Abortamos si htpasswd no generÃ³ salida vÃ¡lida
    - name: âŒ Abortamos si htpasswd fallÃ³ o la salida estÃ¡ vacÃ­a
      fail:
        msg: "âŒ El comando htpasswd fallÃ³ o produjo salida vacÃ­a. Verifica stderr/rc en el debug."
      when: basic_auth_string.rc != 0 or basic_auth_string.stdout | length == 0

    # Codificar la salida de htpasswd en base64
    - name: ðŸ” Codificar salida de htpasswd en base64
      set_fact:
        basic_auth: "{{ basic_auth_string.stdout | b64encode }}"

    # Renderizar plantilla del Secret no sellado
    - name: ðŸ“ Renderizar plantilla del Secret no sellado
      template:
        src: "{{ secret_template }}"
        dest: "{{ rendered_unsealed_secret_path }}"
      vars:
        basic_auth: "{{ basic_auth }}"
        namespace_tpl: "{{ argocd_namespace }}"
        secret_name: "{{ argocd_secret_name }}"

    # Sellar el Secret con kubeseal
    - name: ðŸ” Sellar el Secret con kubeseal
      shell: >
        {{ kubeseal_path }}
        --controller-name sealed-secrets-controller
        --controller-namespace kube-system
        --format yaml
        < {{ rendered_unsealed_secret_path }}
        > {{ sealed_secret_path }}
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      changed_when: true

    # Eliminar el Secret sin sellar
    - name: ðŸ—‘ï¸ Eliminar el Secret sin sellar
      file:
        path: "{{ rendered_unsealed_secret_path }}"
        state: absent

    # Aplicar SealedSecret en el clÃºster
    - name: ðŸš€ Aplicar SealedSecret en el clÃºster
      command: >
        {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }} apply -f {{ sealed_secret_path }}
      register: result
      changed_when: "'created' in result.stdout or 'configured' in result.stdout"