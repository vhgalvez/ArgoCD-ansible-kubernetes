# playbooks/01_generate-auth-secret.yml
# ðŸ” Generar y sellar el Secret de autenticaciÃ³n bÃ¡sica para el Dashboard de Argo CD
---
- name: ðŸ” Generar y sellar el Secret de basic-auth para el Dashboard de Argo CD
  hosts: localhost
  gather_facts: false
  become: false

  vars_files:
    - ../vars/main.yml  # Contiene: argocd_auth_user, argocd_auth_pass, argocd_namespace, kubeconfig_path, kubeseal_path

  vars:
    files_dir: "{{ playbook_dir }}/files"
    secret_template: "../templates/secrets/basic-auth-secret.yaml.j2"
    rendered_unsealed_secret_path: "{{ files_dir }}/argocd-dashboard-secret-unsealed.yaml"
    sealed_secret_path: "{{ files_dir }}/argocd-dashboard-sealed.yaml"

  tasks:

    ######################################################################
    # 1. Verificar requisitos
    ######################################################################

    - name: ðŸ“‹ Verificar que kubeseal estÃ© instalado
      stat:
        path: "{{ kubeseal_path }}"
      register: kubeseal_check

    - name: âŒ Abortar si kubeseal no estÃ¡ instalado
      fail:
        msg: "âŒ kubeseal no estÃ¡ instalado en {{ kubeseal_path }}. Por favor, instÃ¡lalo."
      when: not kubeseal_check.stat.exists

    - name: âš™ï¸ Verificar que las variables de autenticaciÃ³n estÃ©n definidas
      fail:
        msg: "âŒ Las variables ARGOCD_AUTH_USER y ARGOCD_AUTH_PASS deben estar definidas y no vacÃ­as."
      when: argocd_auth_user is not defined or argocd_auth_user == "" or
            argocd_auth_pass is not defined or argocd_auth_pass == ""

    ######################################################################
    # 2. Generar lÃ­nea htpasswd codificada
    ######################################################################

    - name: ðŸ“¦ Instalar utilidad htpasswd si es necesario
      ansible.builtin.package:
        name: "{{ 'httpd-tools' if ansible_facts['os_family'] == 'RedHat' else 'apache2-utils' }}"
        state: present
      become: true

    - name: ðŸ”‘ Generar lÃ­nea htpasswd (bcrypt, entrada silenciosa)
      shell: echo "{{ argocd_auth_pass }}" | htpasswd -i -B -n "{{ argocd_auth_user }}"
      register: basic_auth_string
      no_log: true
      changed_when: false

    - name: ðŸ” Codificar "user:hash" en base64
      set_fact:
        basic_auth: "{{ basic_auth_string.stdout | b64encode }}"

    ######################################################################
    # 3. Renderizar plantilla del Secret y sellarlo
    ######################################################################

    - name: ðŸ“ Renderizar plantilla del Secret no sellado
      template:
        src: "{{ secret_template }}"
        dest: "{{ rendered_unsealed_secret_path }}"
      vars:
        namespace_tpl: "{{ argocd_namespace }}"
        secret_name: "argocd-dashboard-auth"
        basic_auth: "{{ basic_auth }}"

    - name: ðŸ” Sellar el Secret con kubeseal
      shell: >
        {{ kubeseal_path }}
        --controller-name sealed-secrets-controller
        --controller-namespace kube-system
        --format yaml
        < {{ rendered_unsealed_secret_path }} > {{ sealed_secret_path }}
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      changed_when: true

    ######################################################################
    # 4. Aplicar el SealedSecret y limpiar archivos temporales
    ######################################################################

    - name: ðŸ—‘ï¸ Eliminar archivo temporal del Secret sin sellar
      file:
        path: "{{ rendered_unsealed_secret_path }}"
        state: absent
      changed_when: false

    - name: ðŸš€ Aplicar SealedSecret al clÃºster
      ansible.builtin.command:
        cmd: >
          {{ kubectl_path }} --kubeconfig {{ kubeconfig_path }}
          apply -f {{ sealed_secret_path }}
      register: apply_result
      changed_when: "'created' in apply_result.stdout or 'configured' in apply_result.stdout"
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"